/* 
    Node 事件


    Node 实际上是运行在死循环中
    while(true) {
        ...
    }
    在这个死循环中， node不断发射事件，监听事件和执行回调逻辑

    事件来源主要有两种： 一是Node自身所发射出的事件， 二是来自Node自身运行的环境
    监听事件： 回调都是要依附于相应的事件
    执行回调逻辑：本质上都是由底层来执行的

    关于IO操作的异步执行的逻辑：
    1. 同步模式
    2. 异步模式：poll epoll

    IOCP, libuv

    所谓单线程是指Node主逻辑执行在主线程

    当我们在程序中引入某个第三方模块时，那么整体的全部执行逻辑如下所示：

    Node ——> 第三方模块 ——> 原生模块 ——> 原生模块的实现 ——> c++模块 ——> 
    libuv ——> 线程池 ——> 线程 ——> 执行底层的IO操作（操作系统调用）


    Node 完整的事件循环逻辑：
    1. 启动Node运行时
    2. 检测是否有待处理的事件
    3. 如果没有，回到循环开始
    4. 如果有，那么从事件循环队列中取出一个事件
    5. 判断当前这个事件有没有与之关联的事件处理器（回调）
    6. 如果没有，回到循环开始
    7. 如果有，则执行回调
    8. 回到循环开始，开始新一轮的事件监测流程

    整个Node的执行过程实际上是由完整的事件循环机制 + 底层的操作系统异步IO调用 + 线程池（底层库实现或由操作系统提供）共同配合来完成的

    对于单线程的Node来说，是否无法利用到多核的优势呢？

    对于Node的主线程来说，它只能运行在一个核上面。
    对于底层的线程来说，它们却可以运行在多个核上面，当然也可以同时运行，因此它们完全可以利用多核的优势。
*/